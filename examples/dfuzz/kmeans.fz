/*
  From sized-fuzz.pdf

   Missing types:
   - None.

   Missing functions:
   - iterate
*/

function kmeans
  forall (i : size, j : size, e : sens, p : space)
  (iters :[p][1] nat[i])
  (eps   :[p][1] num[e])
  (db    :[p][3 * i * e] (num,[p] num) bag)
  (centers :[p][1] list((num,[p] num))[j])
  (iterate :[p][1] (num[e]) -> ((num,[p] num) bag) -o[p][3*e] (list((num,[p] num))[j]) -> (fuzzy list((num,[p] num))[j]))
  : fuzzy list((num,[p] num))[j] {
    numcase iters of fuzzy list((num,[p] num))[j] {
        Z      => return[p] centers
      | S n[n] =>
        sample next_centers = kmeans[n][j][e][p] n eps db centers iterate;
        iterate eps db next_centers
    }
  }

kmeans

/* Using a more mathematical syntax

val kmeans : ∀ i, j : ι. ∀ ε : r .
    ℕ[i] → ℝ[e] → Bag(ℝ,ℝ) ⊸ [3 * i * e]
    (ℝ[e] → Bag(ℝ,ℝ) [3 * i * e]⊸ List(ℝ,ℝ)[j] → ◯ List(ℝ,ℝ)[j]) ⊸
    ◯ List(ℝ,ℝ)[j]

let kmeans iters eps db center iterate =
  case iters of
      0     => return centers
    | n + 1 => let ◯ next_centers = kmeans n eps db centers iterate in
               iterate eps db next_centers

*/

